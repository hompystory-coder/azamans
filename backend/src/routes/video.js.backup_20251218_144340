// ë¡œì»¬ FFmpeg ê¸°ë°˜ ë¹„ë””ì˜¤ ìƒì„± API
// Shotstack API ë¹„ìš© ì œë¡œ - ì™„ì „ ë¬´ë£Œ
import express from 'express';
import videoRenderer from '../utils/videoRenderer.js';

const router = express.Router();

// ë¹„ë””ì˜¤ ìƒì„± ìƒíƒœ ì €ì¥ (í”„ë¡œë•ì…˜ì—ì„œëŠ” Redis ì‚¬ìš© ê¶Œì¥)
const videoJobs = new Map();

/**
 * POST /api/video/generate
 * ë¡œì»¬ FFmpegë¡œ ë¹„ë””ì˜¤ ìƒì„±
 * - API ë¹„ìš© ì œë¡œ
 * - ë¹ ë¥¸ ì²˜ë¦¬ ì†ë„
 * - ì™„ì „í•œ ì»¤ìŠ¤í„°ë§ˆì´ì§•
 */
router.post('/generate', async (req, res) => {
  try {
    const { scenes, settings } = req.body;

    // ì…ë ¥ ê²€ì¦
    if (!scenes || scenes.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'ì¥ë©´ ë°ì´í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤.'
      });
    }

    // ê° ì¥ë©´ì— í•„ìˆ˜ í•„ë“œ í™•ì¸
    for (let i = 0; i < scenes.length; i++) {
      const scene = scenes[i];
      if (!scene.imageUrl) {
        return res.status(400).json({
          success: false,
          error: `ì¥ë©´ ${i + 1}ì— ì´ë¯¸ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.`
        });
      }
      //       if (!scene.audioUrl) {
      //         return res.status(400).json({
      //           success: false,
      //           error: `ì¥ë©´ ${i + 1}ì— ìŒì„±ì´ í•„ìš”í•©ë‹ˆë‹¤.`
      //         });
      //       }
    }

    console.log(`ğŸ¬ ë¡œì»¬ FFmpeg ë¹„ë””ì˜¤ ìƒì„± ì‹œì‘: ${scenes.length}ê°œ ì¥ë©´`);
    console.log(`ğŸ’° API ë¹„ìš©: â‚©0 (ë¬´ë£Œ!)`);

    // ë¹„ë””ì˜¤ ID ìƒì„±
    const videoId = `video_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;

    // ì´ˆê¸° ìƒíƒœ ì €ì¥
    videoJobs.set(videoId, {
      status: 'processing',
      progress: 0,
      message: 'ë¹„ë””ì˜¤ ìƒì„± ì¤€ë¹„ ì¤‘...',
      startTime: Date.now(),
      scenes: scenes.length
    });

    // ì¦‰ì‹œ ì‘ë‹µ (ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬)
    res.json({
      success: true,
      data: {
        videoId,
        status: 'processing',
        message: `ë¡œì»¬ FFmpegë¡œ ë¹„ë””ì˜¤ ìƒì„± ì‹œì‘! (API ë¹„ìš© â‚©0)`,
        estimatedTime: `ì•½ ${scenes.length * 10}ì´ˆ`,
        checkUrl: `/api/video/status/${videoId}`
      }
    });

    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¹„ë””ì˜¤ ìƒì„±
    (async () => {
      try {
        console.log(`ğŸš€ ë°±ê·¸ë¼ìš´ë“œ ë¹„ë””ì˜¤ ìƒì„± ì‹œì‘: ${videoId}`);

        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        videoJobs.set(videoId, {
          ...videoJobs.get(videoId),
          progress: 10,
          message: 'ì¥ë©´ ë¹„ë””ì˜¤ ìƒì„± ì¤‘...'
        });

        // ë¹„ë””ì˜¤ ìƒì„± (ë¡œì»¬ FFmpeg ì‚¬ìš©)
        const result = await videoRenderer.generateVideo(scenes, settings);

        // ì™„ë£Œ ìƒíƒœ ì—…ë°ì´íŠ¸
        const endTime = Date.now();
        const duration = Math.round((endTime - videoJobs.get(videoId).startTime) / 1000);

        videoJobs.set(videoId, {
          status: 'completed',
          progress: 100,
          message: 'ë¹„ë””ì˜¤ ìƒì„± ì™„ë£Œ!',
          videoUrl: result.videoUrl,
          videoPath: result.videoPath,
          videoId: result.videoId,
          size: result.size,
          duration: result.duration,
          processingTime: duration,
          cost: 0 // ë¬´ë£Œ!
        });

        console.log(`âœ… ë¹„ë””ì˜¤ ìƒì„± ì™„ë£Œ: ${videoId}`);
        console.log(`   ì²˜ë¦¬ ì‹œê°„: ${duration}ì´ˆ`);
        console.log(`   íŒŒì¼ í¬ê¸°: ${(result.size / 1024 / 1024).toFixed(2)} MB`);
        console.log(`   ë¹„ìš©: â‚©0 (ë¬´ë£Œ!)`);

      } catch (error) {
        console.error(`âŒ ë¹„ë””ì˜¤ ìƒì„± ì‹¤íŒ¨: ${videoId}`, error);
        
        videoJobs.set(videoId, {
          status: 'failed',
          progress: 0,
          message: 'ë¹„ë””ì˜¤ ìƒì„± ì‹¤íŒ¨',
          error: error.message
        });
      }
    })();

  } catch (error) {
    console.error('âŒ ë¹„ë””ì˜¤ ìƒì„± ìš”ì²­ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * GET /api/video/status/:videoId
 * ë¹„ë””ì˜¤ ìƒì„± ìƒíƒœ í™•ì¸
 */
router.get('/status/:videoId', (req, res) => {
  try {
    const { videoId } = req.params;
    
    const job = videoJobs.get(videoId);

    if (!job) {
      return res.json({
        success: true,
        data: {
          videoId,
          status: 'not_found',
          progress: 0,
          message: 'ë¹„ë””ì˜¤ ì‘ì—…ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
        }
      });
    }

    res.json({
      success: true,
      data: {
        videoId,
        ...job
      }
    });

  } catch (error) {
    console.error('âŒ ìƒíƒœ í™•ì¸ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/video/generate-scene
 * ë‹¨ì¼ ì¥ë©´ ë¹„ë””ì˜¤ ìƒì„± (í…ŒìŠ¤íŠ¸ìš©)
 */
router.post('/generate-scene', async (req, res) => {
  try {
    const { scene, settings } = req.body;

    if (!scene || !scene.imageUrl || !scene.audioUrl) {
      return res.status(400).json({
        success: false,
        error: 'ì¥ë©´ ë°ì´í„°(ì´ë¯¸ì§€, ìŒì„±)ê°€ í•„ìš”í•©ë‹ˆë‹¤.'
      });
    }

    console.log('ğŸ¬ ë‹¨ì¼ ì¥ë©´ ë¹„ë””ì˜¤ ìƒì„±...');

    // ë‹¨ì¼ ì¥ë©´ ìƒì„±
    const scenePath = await videoRenderer.createSceneVideo(scene, 0, settings);

    res.json({
      success: true,
      data: {
        scenePath,
        message: 'ì¥ë©´ ë¹„ë””ì˜¤ ìƒì„± ì™„ë£Œ'
      }
    });

  } catch (error) {
    console.error('âŒ ì¥ë©´ ìƒì„± ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * DELETE /api/video/:videoId
 * ë¹„ë””ì˜¤ ì‚­ì œ
 */
router.delete('/:videoId', async (req, res) => {
  try {
    const { videoId } = req.params;
    
    const job = videoJobs.get(videoId);
    
    if (!job) {
      return res.status(404).json({
        success: false,
        error: 'ë¹„ë””ì˜¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
      });
    }

    if (job.videoPath) {
      const fs = await import('fs/promises');
      try {
        await fs.unlink(job.videoPath);
        console.log(`ğŸ—‘ï¸  ë¹„ë””ì˜¤ íŒŒì¼ ì‚­ì œ: ${job.videoPath}`);
      } catch (error) {
        console.error('íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨:', error);
      }
    }

    videoJobs.delete(videoId);

    res.json({
      success: true,
      message: 'ë¹„ë””ì˜¤ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.'
    });

  } catch (error) {
    console.error('âŒ ë¹„ë””ì˜¤ ì‚­ì œ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * GET /api/video/jobs/list
 * ëª¨ë“  ë¹„ë””ì˜¤ ì‘ì—… ëª©ë¡
 */
router.get('/jobs/list', (req, res) => {
  try {
    const jobs = Array.from(videoJobs.entries()).map(([id, job]) => ({
      videoId: id,
      ...job
    }));

    res.json({
      success: true,
      data: {
        total: jobs.length,
        jobs: jobs.sort((a, b) => b.startTime - a.startTime)
      }
    });

  } catch (error) {
    console.error('âŒ ì‘ì—… ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/video/jobs/cleanup
 * ì™„ë£Œëœ ì‘ì—… ì •ë¦¬
 */
router.post('/jobs/cleanup', (req, res) => {
  try {
    let cleaned = 0;
    const now = Date.now();
    const maxAge = 24 * 60 * 60 * 1000; // 24ì‹œê°„

    for (const [videoId, job] of videoJobs.entries()) {
      if (job.status === 'completed' || job.status === 'failed') {
        if (now - job.startTime > maxAge) {
          videoJobs.delete(videoId);
          cleaned++;
        }
      }
    }

    res.json({
      success: true,
      message: `${cleaned}ê°œì˜ ì˜¤ë˜ëœ ì‘ì—…ì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`
    });

  } catch (error) {
    console.error('âŒ ì‘ì—… ì •ë¦¬ ì˜¤ë¥˜:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ì •ê¸°ì ìœ¼ë¡œ ì˜¤ë˜ëœ ì‘ì—… ì •ë¦¬ (1ì‹œê°„ë§ˆë‹¤)
setInterval(() => {
  const now = Date.now();
  const maxAge = 24 * 60 * 60 * 1000;
  let cleaned = 0;

  for (const [videoId, job] of videoJobs.entries()) {
    if (job.status === 'completed' || job.status === 'failed') {
      if (now - job.startTime > maxAge) {
        videoJobs.delete(videoId);
        cleaned++;
      }
    }
  }

  if (cleaned > 0) {
    console.log(`ğŸ—‘ï¸  ${cleaned}ê°œì˜ ì˜¤ë˜ëœ ë¹„ë””ì˜¤ ì‘ì—… ì •ë¦¬ ì™„ë£Œ`);
  }
}, 60 * 60 * 1000);

export default router;
