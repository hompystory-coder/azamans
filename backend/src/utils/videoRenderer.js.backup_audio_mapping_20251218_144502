// ë¡œì»¬ FFmpeg ê¸°ë°˜ ë¹„ë””ì˜¤ ë Œë”ëŸ¬
// Shotstack API ë¹„ìš© ì œë¡œ - ì™„ì „ ë¬´ë£Œ ë¡œì»¬ ì²˜ë¦¬
import ffmpeg from 'fluent-ffmpeg';
import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';
import { createWriteStream } from 'fs';
import axios from 'axios';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ì¶œë ¥ ë””ë ‰í† ë¦¬ ì„¤ì •
const OUTPUT_DIR = process.env.OUTPUT_DIR || '/tmp/outputs/videos';
const TEMP_DIR = path.join(OUTPUT_DIR, 'temp');

/**
 * ë¹„ë””ì˜¤ ë Œë”ëŸ¬ í´ë˜ìŠ¤
 * - ë¡œì»¬ FFmpeg ì‚¬ìš©ìœ¼ë¡œ API ë¹„ìš© ì œë¡œ
 * - ìë§‰/ì œëª© 2ì¤„ ì¤‘ì•™ ì •ë ¬ ì§€ì›
 * - ë°°ê²½ ì´ë¯¸ì§€, ìŒì•…, íš¨ê³¼ ì§€ì›
 */
class VideoRenderer {
  constructor() {
    this.ensureDirs();
  }

  /**
   * í•„ìš”í•œ ë””ë ‰í† ë¦¬ ìƒì„±
   */
  async ensureDirs() {
    try {
      await fs.mkdir(OUTPUT_DIR, { recursive: true });
      await fs.mkdir(TEMP_DIR, { recursive: true });
      console.log('âœ… ë¹„ë””ì˜¤ ì¶œë ¥ ë””ë ‰í† ë¦¬ ì¤€ë¹„ ì™„ë£Œ');
    } catch (error) {
      console.error('âŒ ë””ë ‰í† ë¦¬ ìƒì„± ì‹¤íŒ¨:', error);
    }
  }

  /**
   * URLì—ì„œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ
   */
  async downloadFile(url, outputPath) {
    try {
      const response = await axios({
        method: 'GET',
        url: url,
        responseType: 'stream'
      });

      const writer = createWriteStream(outputPath);
      response.data.pipe(writer);

      return new Promise((resolve, reject) => {
        writer.on('finish', resolve);
        writer.on('error', reject);
      });
    } catch (error) {
      console.error(`âŒ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${url}`, error);
      throw error;
    }
  }

  /**
   * ìë§‰ í…ìŠ¤íŠ¸ë¥¼ FFmpeg í•„í„° í˜•ì‹ìœ¼ë¡œ ë³€í™˜
   * 2ì¤„ ì¤‘ì•™ ì •ë ¬, ê·¸ë¦¼ì íš¨ê³¼, í…Œë‘ë¦¬ ì§€ì›
   */
  createSubtitleFilter(text, settings = {}) {
    const {
      fontFamily = 'NanumGothicBold',
      fontSize = 48,
      fontColor = 'white',
      yOffset = 340,
      borderWidth = 3,
      borderColor = 'black',
      shadowX = 2,
      shadowY = 2
    } = settings;

    // í…ìŠ¤íŠ¸ ì´ìŠ¤ì¼€ì´í”„
    const escapedText = text
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/:/g, '\\:')
      .replace(/\n/g, '\\n');

    // FFmpeg drawtext í•„í„°
    return `drawtext=` +
      `text='${escapedText}':` +
      `fontfile=/usr/share/fonts/truetype/nanum/${fontFamily}.ttf:` +
      `fontsize=${fontSize}:` +
      `fontcolor=${fontColor}:` +
      `x=(w-text_w)/2:` +  // ì¤‘ì•™ ì •ë ¬
      `y=h-${yOffset}:` +
      `borderw=${borderWidth}:` +
      `bordercolor=${borderColor}:` +
      `shadowx=${shadowX}:` +
      `shadowy=${shadowY}`;
  }

  /**
   * ì œëª© í…ìŠ¤íŠ¸ë¥¼ FFmpeg í•„í„° í˜•ì‹ìœ¼ë¡œ ë³€í™˜
   * 2ì¤„ ì¤‘ì•™ ì •ë ¬
   */
  createTitleFilter(text, settings = {}) {
    const {
      fontFamily = 'NanumGothicBold',
      fontSize = 56,
      fontColor = 'white',
      yOffset = 270,
      borderWidth = 4,
      borderColor = 'black',
      shadowX = 3,
      shadowY = 3
    } = settings;

    const escapedText = text
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/:/g, '\\:')
      .replace(/\n/g, '\\n');

    return `drawtext=` +
      `text='${escapedText}':` +
      `fontfile=/usr/share/fonts/truetype/nanum/${fontFamily}.ttf:` +
      `fontsize=${fontSize}:` +
      `fontcolor=${fontColor}:` +
      `x=(w-text_w)/2:` +
      `y=h-${yOffset}:` +
      `borderw=${borderWidth}:` +
      `bordercolor=${borderColor}:` +
      `shadowx=${shadowX}:` +
      `shadowy=${shadowY}`;
  }

  /**
   * ë‹¨ì¼ ì¥ë©´ ë¹„ë””ì˜¤ ìƒì„±
   * ì´ë¯¸ì§€ + ìŒì„± + ìë§‰ + ì œëª© ê²°í•©
   */
  async createSceneVideo(scene, sceneIndex, settings = {}) {
    const sceneId = `scene_${Date.now()}_${sceneIndex}`;
    const outputPath = path.join(TEMP_DIR, `${sceneId}.mp4`);

    console.log(`ğŸ¬ ì¥ë©´ ${sceneIndex + 1} ìƒì„± ì¤‘...`);

    try {
      // 1. ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ
      const imagePath = path.join(TEMP_DIR, `${sceneId}_image.jpg`);
      if (scene.imageUrl) {
        await this.downloadFile(scene.imageUrl, imagePath);
      }

      // 2. ìŒì„± ë‹¤ìš´ë¡œë“œ
      const audioPath = path.join(TEMP_DIR, `${sceneId}_audio.mp3`);
      if (scene.audioUrl) {
        await this.downloadFile(scene.audioUrl, audioPath);
      }

      // 3. FFmpeg í•„í„° ìƒì„±
      const filters = [];

      // ë°°ê²½ ì´ë¯¸ì§€ ì²˜ë¦¬
      if (settings.bgImage) {
        filters.push(`[0:v]scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2[bg]`);
      } else {
        filters.push(`[0:v]scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920[bg]`);
      }

      // ìë§‰ ì¶”ê°€
      if (scene.subtitle) {
        const subtitleFilter = this.createSubtitleFilter(
          scene.subtitle,
          settings.subtitleSettings || {}
        );
        filters.push(`[bg]${subtitleFilter}[sub]`);
      }

      // ì œëª© ì¶”ê°€
      if (scene.title) {
        const titleFilter = this.createTitleFilter(
          scene.title,
          settings.titleSettings || {}
        );
        const inputLabel = scene.subtitle ? '[sub]' : '[bg]';
        filters.push(`${inputLabel}${titleFilter}[final]`);
      }

      // 4. FFmpeg ì‹¤í–‰
      return new Promise((resolve, reject) => {
        const command = ffmpeg()
          .input(imagePath)
          .inputOptions(['-loop 1']);

        if (scene.audioUrl) {
          command.input(audioPath);
        }

        command
          .complexFilter(filters)
          .outputOptions([
            '-map', scene.title || scene.subtitle ? '[final]' : '[bg]',
            '-map', scene.audioUrl ? '1:a' : '0:a',
            '-c:v', 'libx264',
            '-preset', 'medium',
            '-crf', '23',
            '-c:a', 'aac',
            '-b:a', '128k',
            '-pix_fmt', 'yuv420p',
            '-shortest',
            '-t', scene.duration || '3'
          ])
          .output(outputPath)
          .on('start', (cmd) => {
            console.log(`   FFmpeg ì‹œì‘: ${cmd}`);
          })
          .on('progress', (progress) => {
            console.log(`   ì§„í–‰ë¥ : ${Math.round(progress.percent || 0)}%`);
          })
          .on('end', () => {
            console.log(`âœ… ì¥ë©´ ${sceneIndex + 1} ì™„ë£Œ: ${outputPath}`);
            // ì„ì‹œ íŒŒì¼ ì •ë¦¬
            this.cleanupTempFiles([imagePath, audioPath]).catch(console.error);
            resolve(outputPath);
          })
          .on('error', (error) => {
            console.error(`âŒ ì¥ë©´ ${sceneIndex + 1} ì‹¤íŒ¨:`, error);
            reject(error);
          })
          .run();
      });

    } catch (error) {
      console.error(`âŒ ì¥ë©´ ${sceneIndex + 1} ìƒì„± ì‹¤íŒ¨:`, error);
      throw error;
    }
  }

  /**
   * ëª¨ë“  ì¥ë©´ ë¹„ë””ì˜¤ë¥¼ í•˜ë‚˜ë¡œ ê²°í•©
   * ë°°ê²½ ìŒì•… ì¶”ê°€ ì§€ì›
   */
  async concatenateScenes(scenePaths, settings = {}) {
    const videoId = `video_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
    const outputPath = path.join(OUTPUT_DIR, `${videoId}.mp4`);
    const concatListPath = path.join(TEMP_DIR, `${videoId}_concat.txt`);

    console.log(`ğŸ”— ${scenePaths.length}ê°œ ì¥ë©´ ê²°í•© ì¤‘...`);

    try {
      // 1. concat ë¦¬ìŠ¤íŠ¸ íŒŒì¼ ìƒì„±
      const concatList = scenePaths
        .map(p => `file '${p}'`)
        .join('\n');
      await fs.writeFile(concatListPath, concatList);

      // 2. ë°°ê²½ ìŒì•… ë‹¤ìš´ë¡œë“œ (ìˆì„ ê²½ìš°)
      let bgMusicPath = null;
      if (settings.bgMusic && settings.bgMusic.url) {
        bgMusicPath = path.join(TEMP_DIR, `${videoId}_bgmusic.mp3`);
        await this.downloadFile(settings.bgMusic.url, bgMusicPath);
      }

      // 3. FFmpegë¡œ ê²°í•©
      return new Promise((resolve, reject) => {
        const command = ffmpeg()
          .input(concatListPath)
          .inputOptions(['-f', 'concat', '-safe', '0']);

        // ë°°ê²½ ìŒì•… ì¶”ê°€
        if (bgMusicPath) {
          command.input(bgMusicPath);
          command.complexFilter([
            '[0:a]volume=1.0[voice]',
            '[1:a]volume=0.3[music]',
            '[voice][music]amix=inputs=2:duration=first[aout]'
          ]);
          command.outputOptions(['-map', '0:v', '-map', '[aout]']);
        }

        command
          .outputOptions([
            '-c:v', 'libx264',
            '-preset', 'medium',
            '-crf', '23',
            '-c:a', 'aac',
            '-b:a', '128k'
          ])
          .output(outputPath)
          .on('start', (cmd) => {
            console.log(`ğŸ¬ ìµœì¢… ê²°í•© ì‹œì‘: ${cmd}`);
          })
          .on('progress', (progress) => {
            console.log(`   ì§„í–‰ë¥ : ${Math.round(progress.percent || 0)}%`);
          })
          .on('end', async () => {
            console.log(`âœ… ìµœì¢… ë¹„ë””ì˜¤ ìƒì„± ì™„ë£Œ: ${outputPath}`);
            
            // ì„ì‹œ íŒŒì¼ ì •ë¦¬
            await this.cleanupTempFiles([
              concatListPath,
              bgMusicPath,
              ...scenePaths
            ]);

            // íŒŒì¼ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const stats = await fs.stat(outputPath);
            
            resolve({
              videoId,
              videoPath: outputPath,
              videoUrl: `/shorts-videos/${videoId}.mp4`,
              size: stats.size,
              duration: settings.totalDuration || scenePaths.length * 3
            });
          })
          .on('error', (error) => {
            console.error('âŒ ë¹„ë””ì˜¤ ê²°í•© ì‹¤íŒ¨:', error);
            reject(error);
          })
          .run();
      });

    } catch (error) {
      console.error('âŒ ë¹„ë””ì˜¤ ê²°í•© ì¤‘ ì˜¤ë¥˜:', error);
      throw error;
    }
  }

  /**
   * ì „ì²´ ë¹„ë””ì˜¤ ìƒì„± í”„ë¡œì„¸ìŠ¤
   * ì¥ë©´ ìƒì„± â†’ ê²°í•© â†’ ìµœì¢… ì¶œë ¥
   */
  async generateVideo(scenes, settings = {}) {
    console.log(`ğŸš€ ë¹„ë””ì˜¤ ìƒì„± ì‹œì‘: ${scenes.length}ê°œ ì¥ë©´`);
    
    try {
      // 1. ê° ì¥ë©´ë³„ ë¹„ë””ì˜¤ ìƒì„±
      const scenePaths = [];
      for (let i = 0; i < scenes.length; i++) {
        const scenePath = await this.createSceneVideo(scenes[i], i, settings);
        scenePaths.push(scenePath);
      }

      // 2. ëª¨ë“  ì¥ë©´ ê²°í•©
      const result = await this.concatenateScenes(scenePaths, settings);

      console.log(`ğŸ‰ ë¹„ë””ì˜¤ ìƒì„± ì™„ë£Œ!`);
      console.log(`   Video ID: ${result.videoId}`);
      console.log(`   Path: ${result.videoPath}`);
      console.log(`   Size: ${(result.size / 1024 / 1024).toFixed(2)} MB`);

      return result;

    } catch (error) {
      console.error('âŒ ë¹„ë””ì˜¤ ìƒì„± ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  /**
   * ì„ì‹œ íŒŒì¼ ì •ë¦¬
   */
  async cleanupTempFiles(filePaths) {
    for (const filePath of filePaths) {
      if (!filePath) continue;
      try {
        await fs.unlink(filePath);
        console.log(`ğŸ—‘ï¸  ì„ì‹œ íŒŒì¼ ì‚­ì œ: ${filePath}`);
      } catch (error) {
        // íŒŒì¼ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
      }
    }
  }

  /**
   * ì˜¤ë˜ëœ ì„ì‹œ íŒŒì¼ ì •ë¦¬ (24ì‹œê°„ ì´ìƒ)
   */
  async cleanupOldTempFiles() {
    try {
      const files = await fs.readdir(TEMP_DIR);
      const now = Date.now();
      const maxAge = 24 * 60 * 60 * 1000; // 24ì‹œê°„

      for (const file of files) {
        const filePath = path.join(TEMP_DIR, file);
        const stats = await fs.stat(filePath);
        
        if (now - stats.mtimeMs > maxAge) {
          await fs.unlink(filePath);
          console.log(`ğŸ—‘ï¸  ì˜¤ë˜ëœ ì„ì‹œ íŒŒì¼ ì‚­ì œ: ${file}`);
        }
      }
    } catch (error) {
      console.error('âŒ ì„ì‹œ íŒŒì¼ ì •ë¦¬ ì‹¤íŒ¨:', error);
    }
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
const videoRenderer = new VideoRenderer();

// ì •ê¸°ì ìœ¼ë¡œ ì˜¤ë˜ëœ ì„ì‹œ íŒŒì¼ ì •ë¦¬ (1ì‹œê°„ë§ˆë‹¤)
setInterval(() => {
  videoRenderer.cleanupOldTempFiles().catch(console.error);
}, 60 * 60 * 1000);

export default videoRenderer;
